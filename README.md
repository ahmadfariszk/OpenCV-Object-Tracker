# OpenCV-Object-Tracker
Repo focused on obejct tracking using OpenCV. Note that the DNN model (with a directory of '/dnn_model') is not uploaded to GitHUb due to its massive file size.

This project is based on a tutorial by Sergio from Pysource at https://www.youtube.com/watch?v=GgGro5IV-cs

The goal of this project is to learn how to use OpenCV and the mechansims at work behind implementing a simple object tracking algorithm. 

## Algorithm breakdown
Tracking objects in this program can be divided into a few steps:
1. Importing the video, the pre-trained dnn model and relevant libraries.
2. Applying object detection on the video on a frame-by-frame basis.
3. Drawing a border around the detected object
4. Linking borders of the same object but from different frames using an array

## Object detection
Before we can track objects we must first detect it. Why? because videos are simply a bunch of images put together in a sequence. By running each frames through and object detection algorithm, we would be able to track it across the video, as the object has been identified on each frame.

For the purpose of understanding the concept behind the pre-provided object-detection.py for the tutorial, I looked up another one of Sergio's videos, at https://www.youtube.com/watch?v=h56M5iUVgGs which taught me how object detection works using YOLO (You Only Look Once) v3. In this project however, I switched over to Yolo v4. The python script that I wrote for this part of the tutorial is named 'concept_object_detector.py' . 

After loading the YOLO model, we process the image by turning it into a blob (Binary Large Object) and then feeding it to the neural network. For this process, we have scaled the image down a bit to help normalize the input data and increase the stability. And then we store the output of the process in an array.

The outs variable holds the output of the YOLO model for a given input image. The outer loop iterates over the outputs of different layers, and the inner loop iterates over individual detections within each layer's output. The detection array inside the inner loop contains information about a specific detected object, as predicted by the YOLO model. The code then processes this information to determine the class and confidence of the detected object.

All objects detcted will have a class ID name given and score that goes along with it. We can get this values from the list "detection" where the values are stored at iterations 5 and above. So we slice this part out to read from it. The rest of the list (iteration 0 - 3) defines the bouding box coordinates for the detected object. Using this coordinates, you can draw the rectangle that would visualise where the detected objects are for humans.

Next, we have to use NMS (Non-Maximum Supression) to reduce the number of redundant and overlapping bounding boxes that may have been generated by the detection algorithm. Naturally, the YOLO model may dectect the same object multiple times with varying level of confidence and at slighly different coordinates so that it overlaps. The use of the NMS in this tutorial assumes that significant overlaps proabbly means its the same object, so the bouding boxes with lower level of confidence are removed.

The finishing step in this tutorail is just assigning random colours for each object detected.


## Object tracking
Once we know how to detect objects in one frame, we can expand it to do object tarcking. After all, object tracking is just object detection run through a video or an animated clip. 

However, the program have no way of automatically knowing that the objects they detected in the previous frame is the same as the objects it detected in the curennt frame or the next. To solve this, before moving to the next iteration of detecting object in a frame, we store the values of bouding boxes of the current frame, and then link it by checking if the previous and current frame objects are close together, then it is probbably the same object. Ofcourse, this method of tracking is rather simplistic and would have problems if an object goes behind another object momentarily.


